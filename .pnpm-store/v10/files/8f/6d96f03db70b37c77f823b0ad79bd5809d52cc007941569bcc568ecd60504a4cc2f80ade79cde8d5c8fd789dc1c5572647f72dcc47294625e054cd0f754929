{"version":3,"sources":["../../src/voice/generation.ts"],"sourcesContent":["// SPDX-FileCopyrightText: 2025 LiveKit, Inc.\n//\n// SPDX-License-Identifier: Apache-2.0\nimport type { AudioFrame } from '@livekit/rtc-node';\nimport { AudioResampler } from '@livekit/rtc-node';\nimport type { ReadableStream, ReadableStreamDefaultReader } from 'stream/web';\nimport {\n  type ChatContext,\n  ChatMessage,\n  FunctionCall,\n  FunctionCallOutput,\n} from '../llm/chat_context.js';\nimport type { ChatChunk } from '../llm/llm.js';\nimport {\n  type ToolChoice,\n  type ToolContext,\n  isAgentHandoff,\n  isFunctionTool,\n  isToolError,\n} from '../llm/tool_context.js';\nimport { isZodSchema, parseZodSchema } from '../llm/zod-utils.js';\nimport { log } from '../log.js';\nimport { IdentityTransform } from '../stream/identity_transform.js';\nimport { Future, Task, shortuuid, toError } from '../utils.js';\nimport { type Agent, type ModelSettings, asyncLocalStorage, isStopResponse } from './agent.js';\nimport type { AgentSession } from './agent_session.js';\nimport type { AudioOutput, LLMNode, TTSNode, TextOutput } from './io.js';\nimport { RunContext } from './run_context.js';\nimport type { SpeechHandle } from './speech_handle.js';\n\n/** @internal */\nexport class _LLMGenerationData {\n  generatedText: string = '';\n  generatedToolCalls: FunctionCall[];\n  id: string;\n\n  constructor(\n    public readonly textStream: ReadableStream<string>,\n    public readonly toolCallStream: ReadableStream<FunctionCall>,\n  ) {\n    this.id = shortuuid('item_');\n    this.generatedToolCalls = [];\n  }\n}\n\n// TODO(brian): remove this class in favor of ToolOutput\nexport class _ToolOutput {\n  output: _JsOutput[];\n  firstToolFut: Future;\n\n  constructor() {\n    this.output = [];\n    this.firstToolFut = new Future();\n  }\n}\n\n// TODO(brian): remove this class in favor of ToolExecutionOutput\nexport class _SanitizedOutput {\n  toolCall: FunctionCall;\n  toolCallOutput?: FunctionCallOutput;\n  replyRequired: boolean;\n  agentTask?: Agent;\n\n  constructor(\n    toolCall: FunctionCall,\n    toolCallOutput: FunctionCallOutput | undefined,\n    replyRequired: boolean,\n    agentTask: Agent | undefined,\n  ) {\n    this.toolCall = toolCall;\n    this.toolCallOutput = toolCallOutput;\n    this.replyRequired = replyRequired;\n    this.agentTask = agentTask;\n  }\n\n  static create(params: {\n    toolCall: FunctionCall;\n    toolCallOutput?: FunctionCallOutput;\n    replyRequired?: boolean;\n    agentTask?: Agent;\n  }) {\n    const { toolCall, toolCallOutput, replyRequired = true, agentTask } = params;\n    return new _SanitizedOutput(toolCall, toolCallOutput, replyRequired, agentTask);\n  }\n}\n\nfunction isValidToolOutput(toolOutput: unknown): boolean {\n  const validTypes = ['string', 'number', 'boolean'];\n\n  if (validTypes.includes(typeof toolOutput)) {\n    return true;\n  }\n\n  if (toolOutput === undefined || toolOutput === null) {\n    return true;\n  }\n\n  if (Array.isArray(toolOutput)) {\n    return toolOutput.every(isValidToolOutput);\n  }\n\n  if (toolOutput instanceof Set) {\n    return Array.from(toolOutput).every(isValidToolOutput);\n  }\n\n  if (toolOutput instanceof Map) {\n    return Array.from(toolOutput.values()).every(isValidToolOutput);\n  }\n\n  if (toolOutput instanceof Object) {\n    return Object.entries(toolOutput).every(\n      ([key, value]) => validTypes.includes(typeof key) && isValidToolOutput(value),\n    );\n  }\n\n  return false;\n}\n\nexport class ToolExecutionOutput {\n  constructor(\n    public readonly toolCall: FunctionCall,\n    public readonly toolCallOutput: FunctionCallOutput | undefined,\n    public readonly agentTask: Agent | undefined,\n    public readonly rawOutput: unknown,\n    public readonly rawException: Error | undefined,\n    public readonly replyRequired: boolean,\n  ) {}\n\n  static create(params: {\n    toolCall: FunctionCall;\n    toolCallOutput?: FunctionCallOutput;\n    agentTask?: Agent;\n    rawOutput: unknown;\n    rawException?: Error;\n    replyRequired?: boolean;\n  }) {\n    const {\n      toolCall,\n      toolCallOutput,\n      agentTask,\n      rawOutput,\n      rawException,\n      replyRequired = true,\n    } = params;\n    return new ToolExecutionOutput(\n      toolCall,\n      toolCallOutput,\n      agentTask,\n      rawOutput,\n      rawException,\n      replyRequired,\n    );\n  }\n}\n\nexport interface ToolOutput {\n  output: ToolExecutionOutput[];\n  firstToolStartedFuture: Future<void>;\n}\n\n// TODO(brian): remove this class in favor of ToolExecutionOutput\nexport class _JsOutput {\n  toolCall: FunctionCall;\n  output: unknown;\n  exception?: Error;\n\n  #logger = log();\n\n  constructor(toolCall: FunctionCall, output: unknown, exception: Error | undefined) {\n    this.toolCall = toolCall;\n    this.output = output;\n    this.exception = exception;\n  }\n\n  static create(params: { toolCall: FunctionCall; output?: unknown; exception?: Error }) {\n    const { toolCall, output = undefined, exception = undefined } = params;\n    return new _JsOutput(toolCall, output, exception);\n  }\n\n  sanitize(): _SanitizedOutput {\n    if (isToolError(this.exception)) {\n      return _SanitizedOutput.create({\n        toolCall: FunctionCall.create({ ...this.toolCall }),\n        toolCallOutput: FunctionCallOutput.create({\n          name: this.toolCall.name,\n          callId: this.toolCall.callId,\n          output: this.exception.message,\n          isError: true,\n        }),\n      });\n    }\n\n    if (isStopResponse(this.exception)) {\n      return _SanitizedOutput.create({\n        toolCall: FunctionCall.create({ ...this.toolCall }),\n      });\n    }\n\n    if (this.exception !== undefined) {\n      return _SanitizedOutput.create({\n        toolCall: FunctionCall.create({ ...this.toolCall }),\n        toolCallOutput: FunctionCallOutput.create({\n          name: this.toolCall.name,\n          callId: this.toolCall.callId,\n          output: 'An internal error occurred while executing the tool.', // Don't send the actual error message, as it may contain sensitive information\n          isError: true,\n        }),\n      });\n    }\n\n    let agentTask: Agent | undefined = undefined;\n    let toolOutput: unknown = this.output;\n    if (isAgentHandoff(this.output)) {\n      agentTask = this.output.agent;\n      toolOutput = this.output.returns;\n    }\n\n    if (!isValidToolOutput(toolOutput)) {\n      this.#logger.error(\n        {\n          callId: this.toolCall.callId,\n          function: this.toolCall.name,\n        },\n        `AI function ${this.toolCall.name} returned an invalid output`,\n      );\n      return _SanitizedOutput.create({\n        toolCall: FunctionCall.create({ ...this.toolCall }),\n        toolCallOutput: undefined,\n      });\n    }\n\n    return _SanitizedOutput.create({\n      toolCall: FunctionCall.create({ ...this.toolCall }),\n      toolCallOutput: FunctionCallOutput.create({\n        name: this.toolCall.name,\n        callId: this.toolCall.callId,\n        output: toolOutput !== undefined ? JSON.stringify(toolOutput) : '', // take the string representation of the output\n        isError: false,\n      }),\n      replyRequired: toolOutput !== undefined, // require a reply if the tool returned an output\n      agentTask,\n    });\n  }\n}\n\nexport function createToolOutput(params: {\n  toolCall: FunctionCall;\n  output?: unknown;\n  exception?: Error;\n}): ToolExecutionOutput {\n  const { toolCall, output, exception } = params;\n  const logger = log();\n\n  // support returning Exception instead of raising them (for devex purposes inside evals)\n  let finalOutput = output;\n  let finalException = exception;\n  if (output instanceof Error) {\n    finalException = output;\n    finalOutput = undefined;\n  }\n\n  if (isToolError(finalException)) {\n    return ToolExecutionOutput.create({\n      toolCall: FunctionCall.create({ ...toolCall }),\n      toolCallOutput: FunctionCallOutput.create({\n        name: toolCall.name,\n        callId: toolCall.callId,\n        output: finalException.message,\n        isError: true,\n      }),\n      rawOutput: finalOutput,\n      rawException: finalException,\n    });\n  }\n\n  if (isStopResponse(finalException)) {\n    return ToolExecutionOutput.create({\n      toolCall: FunctionCall.create({ ...toolCall }),\n      rawOutput: finalOutput,\n      rawException: finalException,\n    });\n  }\n\n  if (finalException !== undefined) {\n    return ToolExecutionOutput.create({\n      toolCall: FunctionCall.create({ ...toolCall }),\n      toolCallOutput: FunctionCallOutput.create({\n        name: toolCall.name,\n        callId: toolCall.callId,\n        output: 'An internal error occurred', // Don't send the actual error message, as it may contain sensitive information\n        isError: true,\n      }),\n      rawOutput: finalOutput,\n      rawException: finalException,\n    });\n  }\n\n  let agentTask: Agent | undefined = undefined;\n  let toolOutput: unknown = finalOutput;\n  if (isAgentHandoff(finalOutput)) {\n    agentTask = finalOutput.agent;\n    toolOutput = finalOutput.returns;\n  }\n\n  if (!isValidToolOutput(toolOutput)) {\n    logger.error(\n      {\n        callId: toolCall.callId,\n        output: finalOutput,\n      },\n      `AI function ${toolCall.name} returned an invalid output`,\n    );\n    return ToolExecutionOutput.create({\n      toolCall: FunctionCall.create({ ...toolCall }),\n      rawOutput: finalOutput,\n      rawException: finalException,\n    });\n  }\n\n  return ToolExecutionOutput.create({\n    toolCall: FunctionCall.create({ ...toolCall }),\n    toolCallOutput: FunctionCallOutput.create({\n      name: toolCall.name,\n      callId: toolCall.callId,\n      output: toolOutput !== undefined ? JSON.stringify(toolOutput) : '', // take the string representation of the output\n      isError: false,\n    }),\n    replyRequired: toolOutput !== undefined, // require a reply if the tool returned an output\n    agentTask,\n    rawOutput: finalOutput,\n    rawException: finalException,\n  });\n}\n\nconst INSTRUCTIONS_MESSAGE_ID = 'lk.agent_task.instructions';\n\n/**\n * Update the instruction message in the chat context or insert a new one if missing.\n *\n * This function looks for an existing instruction message in the chat context using the identifier\n * 'INSTRUCTIONS_MESSAGE_ID'.\n *\n * @param options - The options for updating the instructions.\n * @param options.chatCtx - The chat context to update.\n * @param options.instructions - The instructions to add.\n * @param options.addIfMissing - Whether to add the instructions if they are missing.\n */\nexport function updateInstructions(options: {\n  chatCtx: ChatContext;\n  instructions: string;\n  addIfMissing: boolean;\n}) {\n  const { chatCtx, instructions, addIfMissing } = options;\n\n  const idx = chatCtx.indexById(INSTRUCTIONS_MESSAGE_ID);\n  if (idx !== undefined) {\n    if (chatCtx.items[idx]!.type === 'message') {\n      // create a new instance to avoid mutating the original\n      chatCtx.items[idx] = ChatMessage.create({\n        id: INSTRUCTIONS_MESSAGE_ID,\n        role: 'system',\n        content: [instructions],\n        createdAt: chatCtx.items[idx]!.createdAt,\n      });\n    } else {\n      throw new Error('expected the instructions inside the chatCtx to be of type \"message\"');\n    }\n  } else if (addIfMissing) {\n    // insert the instructions at the beginning of the chat context\n    chatCtx.items.unshift(\n      ChatMessage.create({\n        id: INSTRUCTIONS_MESSAGE_ID,\n        role: 'system',\n        content: [instructions],\n      }),\n    );\n  }\n}\n\nexport function performLLMInference(\n  node: LLMNode,\n  chatCtx: ChatContext,\n  toolCtx: ToolContext,\n  modelSettings: ModelSettings,\n  controller: AbortController,\n): [Task<void>, _LLMGenerationData] {\n  const textStream = new IdentityTransform<string>();\n  const toolCallStream = new IdentityTransform<FunctionCall>();\n\n  const textWriter = textStream.writable.getWriter();\n  const toolCallWriter = toolCallStream.writable.getWriter();\n  const data = new _LLMGenerationData(textStream.readable, toolCallStream.readable);\n\n  const inferenceTask = async (signal: AbortSignal) => {\n    let llmStreamReader: ReadableStreamDefaultReader<string | ChatChunk> | null = null;\n    let llmStream: ReadableStream<string | ChatChunk> | null = null;\n\n    try {\n      llmStream = await node(chatCtx, toolCtx, modelSettings);\n      if (llmStream === null) {\n        await textWriter.close();\n        return;\n      }\n\n      // TODO(brian): add support for dynamic tools\n\n      llmStreamReader = llmStream.getReader();\n      while (true) {\n        if (signal.aborted) {\n          break;\n        }\n        const { done, value: chunk } = await llmStreamReader.read();\n        if (done) {\n          break;\n        }\n\n        if (typeof chunk === 'string') {\n          data.generatedText += chunk;\n          await textWriter.write(chunk);\n          // TODO(shubhra): better way to check??\n        } else {\n          if (chunk.delta === undefined) {\n            continue;\n          }\n\n          if (chunk.delta.toolCalls) {\n            for (const tool of chunk.delta.toolCalls) {\n              if (tool.type !== 'function_call') continue;\n\n              const toolCall = FunctionCall.create({\n                callId: `${data.id}/fnc_${data.generatedToolCalls.length}`,\n                name: tool.name,\n                args: tool.args,\n              });\n\n              data.generatedToolCalls.push(toolCall);\n              await toolCallWriter.write(toolCall);\n            }\n          }\n\n          if (chunk.delta.content) {\n            data.generatedText += chunk.delta.content;\n            await textWriter.write(chunk.delta.content);\n          }\n        }\n\n        // No need to check if chunk is of type other than ChatChunk or string like in\n        // Python since chunk is defined in the type ChatChunk | string in TypeScript\n      }\n    } catch (error) {\n      if (error instanceof DOMException && error.name === 'AbortError') {\n        // Abort signal was triggered, handle gracefully\n        return;\n      }\n      throw error;\n    } finally {\n      llmStreamReader?.releaseLock();\n      await llmStream?.cancel();\n      await textWriter.close();\n      await toolCallWriter.close();\n    }\n  };\n\n  return [\n    Task.from((controller) => inferenceTask(controller.signal), controller, 'performLLMInference'),\n    data,\n  ];\n}\n\nexport function performTTSInference(\n  node: TTSNode,\n  text: ReadableStream<string>,\n  modelSettings: ModelSettings,\n  controller: AbortController,\n): [Task<void>, ReadableStream<AudioFrame>] {\n  const audioStream = new IdentityTransform<AudioFrame>();\n  const outputWriter = audioStream.writable.getWriter();\n  const audioOutputStream = audioStream.readable;\n\n  const inferenceTask = async (signal: AbortSignal) => {\n    let ttsStreamReader: ReadableStreamDefaultReader<AudioFrame> | null = null;\n    let ttsStream: ReadableStream<AudioFrame> | null = null;\n\n    try {\n      ttsStream = await node(text, modelSettings);\n      if (ttsStream === null) {\n        await outputWriter.close();\n        return;\n      }\n\n      ttsStreamReader = ttsStream.getReader();\n      while (true) {\n        if (signal.aborted) {\n          break;\n        }\n        const { done, value: chunk } = await ttsStreamReader.read();\n        if (done) {\n          break;\n        }\n        await outputWriter.write(chunk);\n      }\n    } catch (error) {\n      if (error instanceof DOMException && error.name === 'AbortError') {\n        // Abort signal was triggered, handle gracefully\n        return;\n      }\n      throw error;\n    } finally {\n      ttsStreamReader?.releaseLock();\n      await ttsStream?.cancel();\n      await outputWriter.close();\n    }\n  };\n\n  return [\n    Task.from((controller) => inferenceTask(controller.signal), controller, 'performTTSInference'),\n    audioOutputStream,\n  ];\n}\n\nexport interface _TextOut {\n  text: string;\n  firstTextFut: Future;\n}\n\nasync function forwardText(\n  source: ReadableStream<string>,\n  out: _TextOut,\n  signal: AbortSignal,\n  textOutput: TextOutput | null,\n): Promise<void> {\n  const reader = source.getReader();\n  try {\n    while (true) {\n      if (signal.aborted) {\n        break;\n      }\n      const { done, value: delta } = await reader.read();\n      if (done) break;\n      out.text += delta;\n      if (textOutput !== null) {\n        await textOutput.captureText(delta);\n      }\n      if (!out.firstTextFut.done) {\n        out.firstTextFut.resolve();\n      }\n    }\n  } finally {\n    if (textOutput !== null) {\n      textOutput.flush();\n    }\n    reader?.releaseLock();\n  }\n}\n\nexport function performTextForwarding(\n  source: ReadableStream<string>,\n  controller: AbortController,\n  textOutput: TextOutput | null,\n): [Task<void>, _TextOut] {\n  const out = {\n    text: '',\n    firstTextFut: new Future(),\n  };\n  return [\n    Task.from(\n      (controller) => forwardText(source, out, controller.signal, textOutput),\n      controller,\n      'performTextForwarding',\n    ),\n    out,\n  ];\n}\n\nexport interface _AudioOut {\n  audio: Array<AudioFrame>;\n  firstFrameFut: Future;\n}\n\nasync function forwardAudio(\n  ttsStream: ReadableStream<AudioFrame>,\n  audioOuput: AudioOutput,\n  out: _AudioOut,\n  signal?: AbortSignal,\n): Promise<void> {\n  const reader = ttsStream.getReader();\n  let resampler: AudioResampler | null = null;\n\n  try {\n    while (true) {\n      if (signal?.aborted) {\n        break;\n      }\n\n      const { done, value: frame } = await reader.read();\n      if (done) break;\n\n      out.audio.push(frame);\n\n      if (\n        !out.firstFrameFut.done &&\n        audioOuput.sampleRate &&\n        audioOuput.sampleRate !== frame.sampleRate &&\n        !resampler\n      ) {\n        resampler = new AudioResampler(frame.sampleRate, audioOuput.sampleRate, 1);\n      }\n\n      if (resampler) {\n        for (const f of resampler.push(frame)) {\n          await audioOuput.captureFrame(f);\n        }\n      } else {\n        await audioOuput.captureFrame(frame);\n      }\n\n      // set the first frame future if not already set\n      // (after completing the first frame)\n      if (!out.firstFrameFut.done) {\n        out.firstFrameFut.resolve();\n      }\n    }\n  } finally {\n    reader?.releaseLock();\n    if (resampler) {\n      for (const f of resampler.flush()) {\n        await audioOuput.captureFrame(f);\n      }\n    }\n    audioOuput.flush();\n  }\n}\n\nexport function performAudioForwarding(\n  ttsStream: ReadableStream<AudioFrame>,\n  audioOutput: AudioOutput,\n  controller: AbortController,\n): [Task<void>, _AudioOut] {\n  const out = {\n    audio: [],\n    firstFrameFut: new Future(),\n  };\n  return [\n    Task.from(\n      (controller) => forwardAudio(ttsStream, audioOutput, out, controller.signal),\n      controller,\n      'performAudioForwarding',\n    ),\n    out,\n  ];\n}\n\nexport function performToolExecutions({\n  session,\n  speechHandle,\n  toolCtx,\n  toolChoice,\n  toolCallStream,\n  onToolExecutionStarted = () => {},\n  onToolExecutionCompleted = () => {},\n  controller,\n}: {\n  session: AgentSession;\n  speechHandle: SpeechHandle;\n  toolCtx: ToolContext;\n  toolChoice?: ToolChoice;\n  toolCallStream: ReadableStream<FunctionCall>;\n  onToolExecutionStarted?: (toolCall: FunctionCall) => void;\n  onToolExecutionCompleted?: (toolExecutionOutput: ToolExecutionOutput) => void;\n  controller: AbortController;\n}): [Task<void>, ToolOutput] {\n  const logger = log();\n  const toolOutput: ToolOutput = {\n    output: [],\n    firstToolStartedFuture: new Future(),\n  };\n\n  const toolCompleted = (out: ToolExecutionOutput) => {\n    onToolExecutionCompleted(out);\n    toolOutput.output.push(out);\n  };\n\n  const executeToolsTask = async (controller: AbortController) => {\n    const signal = controller.signal;\n    const reader = toolCallStream.getReader();\n\n    const tasks: Promise<any>[] = [];\n    while (!signal.aborted) {\n      const { done, value: toolCall } = await reader.read();\n      if (signal.aborted) break;\n      if (done) break;\n\n      if (toolChoice === 'none') {\n        logger.error(\n          {\n            function: toolCall.name,\n            speech_id: speechHandle.id,\n          },\n          \"received a tool call with toolChoice set to 'none', ignoring\",\n        );\n        continue;\n      }\n\n      // TODO(brian): assert other toolChoice values\n\n      const tool = toolCtx[toolCall.name];\n      if (!tool) {\n        logger.warn(\n          {\n            function: toolCall.name,\n            speech_id: speechHandle.id,\n          },\n          `unknown AI function ${toolCall.name}`,\n        );\n        continue;\n      }\n\n      if (!isFunctionTool(tool)) {\n        logger.error(\n          {\n            function: toolCall.name,\n            speech_id: speechHandle.id,\n          },\n          `unknown tool type: ${typeof tool}`,\n        );\n        continue;\n      }\n\n      let parsedArgs: object | undefined;\n\n      // Ensure valid arguments\n      try {\n        const jsonArgs = JSON.parse(toolCall.args);\n\n        if (isZodSchema(tool.parameters)) {\n          const result = await parseZodSchema<object>(tool.parameters, jsonArgs);\n          if (result.success) {\n            parsedArgs = result.data;\n          } else {\n            throw result.error;\n          }\n        } else {\n          parsedArgs = jsonArgs;\n        }\n      } catch (rawError) {\n        const error = toError(rawError);\n        logger.error(\n          {\n            function: toolCall.name,\n            arguments: toolCall.args,\n            speech_id: speechHandle.id,\n            error: error.message,\n          },\n          `tried to call AI function ${toolCall.name} with invalid arguments`,\n        );\n        toolCompleted(\n          createToolOutput({\n            toolCall,\n            exception: error,\n          }),\n        );\n        continue;\n      }\n\n      if (!toolOutput.firstToolStartedFuture.done) {\n        toolOutput.firstToolStartedFuture.resolve();\n      }\n\n      onToolExecutionStarted(toolCall);\n\n      logger.info(\n        {\n          function: toolCall.name,\n          arguments: parsedArgs,\n          speech_id: speechHandle.id,\n        },\n        'Executing LLM tool call',\n      );\n\n      const toolExecution = asyncLocalStorage.run({ functionCall: toolCall }, async () => {\n        return await tool.execute(parsedArgs, {\n          ctx: new RunContext(session, speechHandle, toolCall),\n          toolCallId: toolCall.callId,\n          abortSignal: signal,\n        });\n      });\n\n      const tracableToolExecution = async (toolExecTask: Promise<unknown>) => {\n        // TODO(brian): add tracing\n\n        // await for task to complete, if task is aborted, set exception\n        let toolOutput: ToolExecutionOutput | undefined;\n        try {\n          const { result, isAborted } = await waitUntilAborted(toolExecTask, signal);\n          toolOutput = createToolOutput({\n            toolCall,\n            exception: isAborted ? new Error('tool call was aborted') : undefined,\n            output: isAborted ? undefined : result,\n          });\n        } catch (rawError) {\n          logger.error(\n            {\n              function: toolCall.name,\n              speech_id: speechHandle.id,\n              error: toError(rawError).message,\n            },\n            'exception occurred while executing tool',\n          );\n          toolOutput = createToolOutput({\n            toolCall,\n            exception: toError(rawError),\n          });\n        } finally {\n          if (!toolOutput) throw new Error('toolOutput is undefined');\n          toolCompleted(toolOutput);\n        }\n      };\n\n      // wait, not cancelling all tool calling tasks\n      tasks.push(tracableToolExecution(toolExecution));\n    }\n\n    await Promise.allSettled(tasks);\n    if (toolOutput.output.length > 0) {\n      logger.debug(\n        {\n          speech_id: speechHandle.id,\n        },\n        'tools execution completed',\n      );\n    }\n  };\n\n  return [Task.from(executeToolsTask, controller, 'performToolExecutions'), toolOutput];\n}\n\ntype Aborted<T> =\n  | {\n      result: T;\n      isAborted: false;\n    }\n  | {\n      result: undefined;\n      isAborted: true;\n    };\n\nasync function waitUntilAborted<T>(promise: Promise<T>, signal: AbortSignal): Promise<Aborted<T>> {\n  const abortFut = new Future<Aborted<T>>();\n\n  const resolveAbort = () => {\n    if (!abortFut.done) {\n      abortFut.resolve({ result: undefined, isAborted: true });\n    }\n  };\n\n  signal.addEventListener('abort', resolveAbort);\n\n  promise\n    .then((r) => {\n      if (!abortFut.done) {\n        abortFut.resolve({ result: r, isAborted: false });\n      }\n    })\n    .catch((e) => {\n      if (!abortFut.done) {\n        abortFut.reject(e);\n      }\n    })\n    .finally(() => {\n      signal.removeEventListener('abort', resolveAbort);\n    });\n\n  return await abortFut.await;\n}\n\nexport function removeInstructions(chatCtx: ChatContext) {\n  // loop in case there are items with the same id (shouldn't happen!)\n  while (true) {\n    const idx = chatCtx.indexById(INSTRUCTIONS_MESSAGE_ID);\n    if (idx !== undefined) {\n      chatCtx.items.splice(idx, 1);\n    } else {\n      break;\n    }\n  }\n}\n"],"mappings":"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","names":["controller","toolOutput"]}