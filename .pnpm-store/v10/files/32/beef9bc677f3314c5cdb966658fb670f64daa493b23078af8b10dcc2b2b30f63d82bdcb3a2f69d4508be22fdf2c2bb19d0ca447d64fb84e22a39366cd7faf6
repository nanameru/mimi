{"version":3,"sources":["../../src/ipc/supervised_proc.ts"],"sourcesContent":["// SPDX-FileCopyrightText: 2024 LiveKit, Inc.\n//\n// SPDX-License-Identifier: Apache-2.0\nimport type { ChildProcess } from 'node:child_process';\nimport { once } from 'node:events';\nimport pidusage from 'pidusage';\nimport type { RunningJobInfo } from '../job.js';\nimport { log, loggerOptions } from '../log.js';\nimport { Future } from '../utils.js';\nimport type { IPCMessage } from './message.js';\n\nexport interface ProcOpts {\n  initializeTimeout: number;\n  closeTimeout: number;\n  memoryWarnMB: number;\n  memoryLimitMB: number;\n  pingInterval: number;\n  pingTimeout: number;\n  highPingThreshold: number;\n}\n\nexport abstract class SupervisedProc {\n  #opts: ProcOpts;\n  #started = false;\n  #closing = false;\n  #runningJob?: RunningJobInfo = undefined;\n  proc?: ChildProcess;\n  #pingInterval?: ReturnType<typeof setInterval>;\n  #memoryMonitorInterval?: ReturnType<typeof setInterval>;\n  #pongTimeout?: ReturnType<typeof setTimeout>;\n  protected init = new Future();\n  #join = new Future();\n  #logger = log().child({ runningJob: this.#runningJob });\n\n  constructor(\n    initializeTimeout: number,\n    closeTimeout: number,\n    memoryWarnMB: number,\n    memoryLimitMB: number,\n    pingInterval: number,\n    pingTimeout: number,\n    highPingThreshold: number,\n  ) {\n    this.#opts = {\n      initializeTimeout,\n      closeTimeout,\n      memoryWarnMB,\n      memoryLimitMB,\n      pingInterval,\n      pingTimeout,\n      highPingThreshold,\n    };\n  }\n\n  abstract createProcess(): ChildProcess;\n  abstract mainTask(child: ChildProcess): Promise<void>;\n\n  get started(): boolean {\n    return this.#started;\n  }\n\n  get runningJob(): RunningJobInfo | undefined {\n    return this.#runningJob;\n  }\n\n  async start() {\n    if (this.#started) {\n      throw new Error('runner already started');\n    } else if (this.#closing) {\n      throw new Error('runner is closed');\n    }\n\n    this.proc = this.createProcess();\n\n    this.#started = true;\n    this.run();\n  }\n\n  async run() {\n    await this.init.await;\n\n    this.#pingInterval = setInterval(() => {\n      this.proc!.send({ case: 'pingRequest', value: { timestamp: Date.now() } });\n    }, this.#opts.pingInterval);\n\n    this.#pongTimeout = setTimeout(() => {\n      this.#logger.warn('job is unresponsive');\n      clearTimeout(this.#pongTimeout);\n      clearInterval(this.#pingInterval);\n      this.proc!.kill();\n      this.#join.resolve();\n    }, this.#opts.pingTimeout);\n\n    this.#memoryMonitorInterval = setInterval(async () => {\n      const memoryMB = await this.getChildMemoryUsageMB();\n      if (this.#opts.memoryLimitMB > 0 && memoryMB > this.#opts.memoryLimitMB) {\n        this.#logger\n          .child({ memoryUsageMB: memoryMB, memoryLimitMB: this.#opts.memoryLimitMB })\n          .error('process exceeded memory limit, killing process');\n        this.close();\n      } else if (this.#opts.memoryWarnMB > 0 && memoryMB > this.#opts.memoryWarnMB) {\n        this.#logger\n          .child({\n            memoryUsageMB: memoryMB,\n            memoryWarnMB: this.#opts.memoryWarnMB,\n            memoryLimitMB: this.#opts.memoryLimitMB,\n          })\n          .warn('process memory usage is high');\n      }\n    }, 5000);\n\n    const listener = (msg: IPCMessage) => {\n      switch (msg.case) {\n        case 'pongResponse': {\n          const delay = Date.now() - msg.value.timestamp;\n          if (delay > this.#opts.highPingThreshold) {\n            this.#logger.child({ delay }).warn('job executor is unresponsive');\n          }\n          this.#pongTimeout?.refresh();\n          break;\n        }\n        case 'exiting': {\n          this.#logger.child({ reason: msg.value.reason }).debug('job exiting');\n          break;\n        }\n        case 'done': {\n          this.#closing = true;\n          this.proc!.off('message', listener);\n          break;\n        }\n      }\n    };\n    this.proc!.on('message', listener);\n    this.proc!.on('error', (err) => {\n      if (this.#closing) return;\n      this.#logger\n        .child({ err })\n        .warn('job process exited unexpectedly; this likely means the error above caused a crash');\n      this.clearTimers();\n      this.#join.resolve();\n    });\n\n    this.proc!.on('exit', () => {\n      this.#join.resolve();\n    });\n\n    this.mainTask(this.proc!);\n\n    await this.#join.await;\n  }\n\n  async join() {\n    if (!this.#started) {\n      throw new Error('runner not started');\n    }\n\n    await this.#join.await;\n  }\n\n  async initialize() {\n    const timer = setTimeout(() => {\n      const err = new Error('runner initialization timed out');\n      this.init.reject(err);\n      throw err;\n    }, this.#opts.initializeTimeout);\n    this.proc!.send({\n      case: 'initializeRequest',\n      value: {\n        loggerOptions,\n        pingInterval: this.#opts.pingInterval,\n        pingTimeout: this.#opts.pingTimeout,\n        highPingThreshold: this.#opts.highPingThreshold,\n      },\n    });\n    await once(this.proc!, 'message').then(([msg]: IPCMessage[]) => {\n      clearTimeout(timer);\n      if (msg!.case !== 'initializeResponse') {\n        throw new Error('first message must be InitializeResponse');\n      }\n    });\n    this.init.resolve();\n  }\n\n  async close() {\n    if (!this.#started) {\n      return;\n    }\n    this.#closing = true;\n\n    this.proc!.send({ case: 'shutdownRequest' });\n\n    const timer = setTimeout(() => {\n      this.#logger.error('job shutdown is taking too much time');\n      this.proc!.kill();\n    }, this.#opts.closeTimeout);\n    await this.#join.await.then(() => {\n      clearTimeout(timer);\n      this.clearTimers();\n    });\n  }\n\n  async launchJob(info: RunningJobInfo) {\n    if (this.#runningJob) {\n      throw new Error('executor already has a running job');\n    }\n    this.#runningJob = info;\n    this.proc!.send({ case: 'startJobRequest', value: { runningJob: info } });\n  }\n\n  private async getChildMemoryUsageMB(): Promise<number> {\n    const pid = this.proc?.pid;\n    if (!pid) {\n      return 0;\n    }\n    const stats = await pidusage(pid);\n    return stats.memory / (1024 * 1024); // Convert bytes to MB\n  }\n\n  private clearTimers() {\n    clearTimeout(this.#pongTimeout);\n    clearInterval(this.#pingInterval);\n    clearInterval(this.#memoryMonitorInterval);\n  }\n}\n"],"mappings":"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","names":[]}