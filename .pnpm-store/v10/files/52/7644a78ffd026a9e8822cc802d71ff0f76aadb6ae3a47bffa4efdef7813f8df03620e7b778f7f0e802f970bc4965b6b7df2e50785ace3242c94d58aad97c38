{"version":3,"sources":["../../src/ipc/proc_pool.ts"],"sourcesContent":["// SPDX-FileCopyrightText: 2024 LiveKit, Inc.\n//\n// SPDX-License-Identifier: Apache-2.0\nimport { MultiMutex, Mutex } from '@livekit/mutex';\nimport type { RunningJobInfo } from '../job.js';\nimport { Queue } from '../utils.js';\nimport type { InferenceExecutor } from './inference_executor.js';\nimport type { JobExecutor } from './job_executor.js';\nimport { JobProcExecutor } from './job_proc_executor.js';\n\nexport class ProcPool {\n  agent: string;\n  initializeTimeout: number;\n  closeTimeout: number;\n  executors: JobExecutor[] = [];\n  tasks: Promise<void>[] = [];\n  started = false;\n  closed = false;\n  controller = new AbortController();\n  initMutex = new Mutex();\n  procMutex?: MultiMutex;\n  procUnlock?: () => void;\n  warmedProcQueue = new Queue<JobExecutor>();\n  inferenceExecutor?: InferenceExecutor;\n  memoryWarnMB: number;\n  memoryLimitMB: number;\n\n  constructor(\n    agent: string,\n    numIdleProcesses: number,\n    initializeTimeout: number,\n    closeTimeout: number,\n    inferenceExecutor: InferenceExecutor | undefined,\n    memoryWarnMB: number,\n    memoryLimitMB: number,\n  ) {\n    this.agent = agent;\n    if (numIdleProcesses > 0) {\n      this.procMutex = new MultiMutex(numIdleProcesses);\n    }\n    this.initializeTimeout = initializeTimeout;\n    this.closeTimeout = closeTimeout;\n    this.inferenceExecutor = inferenceExecutor;\n    this.memoryWarnMB = memoryWarnMB;\n    this.memoryLimitMB = memoryLimitMB;\n  }\n\n  get processes(): JobExecutor[] {\n    return this.executors;\n  }\n\n  getByJobId(id: string): JobExecutor | null {\n    return this.executors.find((x) => x.runningJob && x.runningJob.job.id === id) || null;\n  }\n\n  async launchJob(info: RunningJobInfo) {\n    let proc: JobExecutor;\n    if (this.procMutex) {\n      proc = await this.warmedProcQueue.get();\n      if (this.procUnlock) {\n        this.procUnlock();\n        this.procUnlock = undefined;\n      }\n    } else {\n      proc = new JobProcExecutor(\n        this.agent,\n        this.inferenceExecutor,\n        this.initializeTimeout,\n        this.closeTimeout,\n        this.memoryWarnMB,\n        this.memoryLimitMB,\n        2500,\n        60000,\n        500,\n      );\n      this.executors.push(proc);\n      await proc.start();\n      await proc.initialize();\n    }\n    await proc.launchJob(info);\n  }\n\n  async procWatchTask() {\n    const proc = new JobProcExecutor(\n      this.agent,\n      this.inferenceExecutor,\n      this.initializeTimeout,\n      this.closeTimeout,\n      this.memoryWarnMB,\n      this.memoryLimitMB,\n      2500,\n      60000,\n      500,\n    );\n\n    try {\n      this.executors.push(proc);\n\n      const unlock = await this.initMutex.lock();\n      if (this.closed) {\n        return;\n      }\n\n      await proc.start();\n      try {\n        await proc.initialize();\n        await this.warmedProcQueue.put(proc);\n      } catch {\n        if (this.procUnlock) {\n          this.procUnlock();\n          this.procUnlock = undefined;\n        }\n      }\n\n      unlock();\n      await proc.join();\n    } finally {\n      const procIndex = this.executors.indexOf(proc);\n      if (procIndex !== -1) {\n        this.executors.splice(procIndex, 1);\n      } else {\n        throw new Error(`proc ${proc} not found in executors`);\n      }\n    }\n  }\n\n  start() {\n    if (this.started) {\n      return;\n    }\n\n    this.started = true;\n    this.run(this.controller.signal);\n  }\n\n  async run(signal: AbortSignal) {\n    if (this.procMutex) {\n      while (!signal.aborted) {\n        this.procUnlock = await this.procMutex.lock();\n        const task = this.procWatchTask();\n        this.tasks.push(task);\n        task.finally(() => {\n          const taskIndex = this.tasks.indexOf(task);\n          if (taskIndex !== -1) {\n            this.tasks.splice(taskIndex, 1);\n          } else {\n            throw new Error(`task ${task} not found in tasks`);\n          }\n        });\n      }\n    }\n  }\n\n  async close() {\n    if (!this.started) {\n      return;\n    }\n    this.closed = true;\n    this.controller.abort();\n    this.warmedProcQueue.items.forEach((e) => e.close());\n    this.executors.forEach((e) => e.close());\n    await Promise.allSettled(this.tasks);\n  }\n}\n"],"mappings":"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","names":[]}