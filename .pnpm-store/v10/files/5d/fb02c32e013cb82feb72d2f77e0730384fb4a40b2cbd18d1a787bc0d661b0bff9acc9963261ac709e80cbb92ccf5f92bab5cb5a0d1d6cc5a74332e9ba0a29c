{"version":3,"sources":["../src/audio.ts"],"sourcesContent":["// SPDX-FileCopyrightText: 2024 LiveKit, Inc.\n//\n// SPDX-License-Identifier: Apache-2.0\nimport ffmpegInstaller from '@ffmpeg-installer/ffmpeg';\nimport { AudioFrame } from '@livekit/rtc-node';\nimport ffmpeg from 'fluent-ffmpeg';\nimport type { ReadableStream } from 'node:stream/web';\nimport { log } from './log.js';\nimport { createStreamChannel } from './stream/stream_channel.js';\nimport type { AudioBuffer } from './utils.js';\n\nffmpeg.setFfmpegPath(ffmpegInstaller.path);\n\nexport interface AudioDecodeOptions {\n  sampleRate?: number;\n  numChannels?: number;\n  /**\n   * Audio format hint (e.g., 'mp3', 'ogg', 'wav', 'opus')\n   * If not provided, FFmpeg will auto-detect\n   */\n  format?: string;\n  abortSignal?: AbortSignal;\n}\n\nexport function calculateAudioDurationSeconds(frame: AudioBuffer) {\n  // TODO(AJS-102): use frame.durationMs once available in rtc-node\n  return Array.isArray(frame)\n    ? frame.reduce((sum, a) => sum + a.samplesPerChannel / a.sampleRate, 0)\n    : frame.samplesPerChannel / frame.sampleRate;\n}\n\n/** AudioByteStream translates between LiveKit AudioFrame packets and raw byte data. */\nexport class AudioByteStream {\n  #sampleRate: number;\n  #numChannels: number;\n  #bytesPerFrame: number;\n  #buf: Int8Array;\n  #logger = log();\n\n  constructor(sampleRate: number, numChannels: number, samplesPerChannel: number | null = null) {\n    this.#sampleRate = sampleRate;\n    this.#numChannels = numChannels;\n\n    if (samplesPerChannel === null) {\n      samplesPerChannel = Math.floor(sampleRate / 10); // 100ms by default\n    }\n\n    this.#bytesPerFrame = numChannels * samplesPerChannel * 2; // 2 bytes per sample (Int16)\n    this.#buf = new Int8Array();\n  }\n\n  write(data: ArrayBuffer): AudioFrame[] {\n    this.#buf = new Int8Array([...this.#buf, ...new Int8Array(data)]);\n\n    const frames: AudioFrame[] = [];\n    while (this.#buf.length >= this.#bytesPerFrame) {\n      const frameData = this.#buf.slice(0, this.#bytesPerFrame);\n      this.#buf = this.#buf.slice(this.#bytesPerFrame);\n\n      frames.push(\n        new AudioFrame(\n          new Int16Array(frameData.buffer),\n          this.#sampleRate,\n          this.#numChannels,\n          frameData.length / 2,\n        ),\n      );\n    }\n\n    return frames;\n  }\n\n  flush(): AudioFrame[] {\n    if (this.#buf.length % (2 * this.#numChannels) !== 0) {\n      this.#logger.warn('AudioByteStream: incomplete frame during flush, dropping');\n      return [];\n    }\n\n    const frames = [\n      new AudioFrame(\n        new Int16Array(this.#buf.buffer),\n        this.#sampleRate,\n        this.#numChannels,\n        this.#buf.length / 2,\n      ),\n    ];\n\n    this.#buf = new Int8Array(); // Clear buffer after flushing\n    return frames;\n  }\n}\n\n/**\n * Decode an audio file into AudioFrame instances\n *\n * @param filePath - Path to the audio file\n * @param options - Decoding options\n * @returns AsyncGenerator that yields AudioFrame objects\n *\n * @example\n * ```typescript\n * for await (const frame of audioFramesFromFile('audio.ogg', { sampleRate: 48000 })) {\n *   console.log('Frame:', frame.samplesPerChannel, 'samples');\n * }\n * ```\n */\nexport function audioFramesFromFile(\n  filePath: string,\n  options: AudioDecodeOptions = {},\n): ReadableStream<AudioFrame> {\n  const sampleRate = options.sampleRate ?? 48000;\n  const numChannels = options.numChannels ?? 1;\n\n  const audioStream = new AudioByteStream(sampleRate, numChannels);\n  const channel = createStreamChannel<AudioFrame>();\n  const logger = log();\n\n  // TODO (Brian): decode WAV using a custom decoder instead of FFmpeg\n  const command = ffmpeg(filePath)\n    .inputOptions([\n      '-probesize',\n      '32',\n      '-analyzeduration',\n      '0',\n      '-fflags',\n      '+nobuffer+flush_packets',\n      '-flags',\n      'low_delay',\n    ])\n    .format('s16le') // signed 16-bit little-endian PCM to be consistent cross-platform\n    .audioChannels(numChannels)\n    .audioFrequency(sampleRate);\n\n  let commandRunning = true;\n\n  const onClose = () => {\n    logger.debug('Audio file playback aborted');\n\n    channel.close();\n    if (commandRunning) {\n      commandRunning = false;\n      command.kill('SIGKILL');\n    }\n  };\n\n  const outputStream = command.pipe();\n  options.abortSignal?.addEventListener('abort', onClose, { once: true });\n\n  outputStream.on('data', (chunk: Buffer) => {\n    const arrayBuffer = chunk.buffer.slice(\n      chunk.byteOffset,\n      chunk.byteOffset + chunk.byteLength,\n    ) as ArrayBuffer;\n\n    const frames = audioStream.write(arrayBuffer);\n    for (const frame of frames) {\n      channel.write(frame);\n    }\n  });\n\n  outputStream.on('end', () => {\n    const frames = audioStream.flush();\n    for (const frame of frames) {\n      channel.write(frame);\n    }\n    commandRunning = false;\n    channel.close();\n  });\n\n  outputStream.on('error', (err: Error) => {\n    logger.error(err);\n    commandRunning = false;\n    onClose();\n  });\n\n  return channel.stream();\n}\n\n/**\n * Loop audio frames from a file indefinitely\n *\n * @param filePath - Path to the audio file\n * @param options - Decoding options\n * @returns AsyncGenerator that yields AudioFrame objects in an infinite loop\n */\nexport async function* loopAudioFramesFromFile(\n  filePath: string,\n  options: AudioDecodeOptions = {},\n): AsyncGenerator<AudioFrame, void, unknown> {\n  const frames: AudioFrame[] = [];\n  const logger = log();\n\n  for await (const frame of audioFramesFromFile(filePath, options)) {\n    frames.push(frame);\n    yield frame;\n  }\n\n  while (!options.abortSignal?.aborted) {\n    for (const frame of frames) {\n      yield frame;\n    }\n  }\n\n  logger.debug('Audio file playback loop finished');\n}\n"],"mappings":"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","names":[]}