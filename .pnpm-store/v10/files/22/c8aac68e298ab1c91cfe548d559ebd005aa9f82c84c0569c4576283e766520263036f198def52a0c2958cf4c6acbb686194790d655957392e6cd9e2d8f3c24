{"version":3,"sources":["../../src/stream/stream_channel.test.ts"],"sourcesContent":["// SPDX-FileCopyrightText: 2025 LiveKit, Inc.\n//\n// SPDX-License-Identifier: Apache-2.0\nimport { describe, expect, it } from 'vitest';\nimport { createStreamChannel } from './stream_channel.js';\n\ndescribe('StreamChannel', () => {\n  it('should write and read a single value', async () => {\n    const channel = createStreamChannel<string>();\n    const reader = channel.stream().getReader();\n\n    await channel.write('test value');\n    await channel.close();\n\n    const result = await reader.read();\n    expect(result.done).toBe(false);\n    expect(result.value).toBe('test value');\n\n    const nextResult = await reader.read();\n    expect(nextResult.done).toBe(true);\n  });\n\n  it('should write and read multiple values in sequence', async () => {\n    const channel = createStreamChannel<string>();\n    const reader = channel.stream().getReader();\n\n    const testValues = ['first', 'second', 'third'];\n\n    for (const value of testValues) {\n      await channel.write(value);\n    }\n    await channel.close();\n\n    const results: string[] = [];\n    let result = await reader.read();\n    while (!result.done) {\n      results.push(result.value);\n      result = await reader.read();\n    }\n\n    expect(results).toEqual(testValues);\n  });\n\n  it('should handle arrays', async () => {\n    const channel = createStreamChannel<number[]>();\n    const reader = channel.stream().getReader();\n\n    const testArray = [1, 2, 3, 4, 5];\n    await channel.write(testArray);\n    await channel.close();\n\n    const result = await reader.read();\n    expect(result.value).toEqual(testArray);\n    expect(result.value).toBe(testArray);\n  });\n\n  it('should work with concurrent writing and reading', async () => {\n    const channel = createStreamChannel<string>();\n    const reader = channel.stream().getReader();\n\n    const testData = ['chunk1', 'chunk2', 'chunk3'];\n    const results: string[] = [];\n\n    const readPromise = (async () => {\n      let result = await reader.read();\n      while (!result.done) {\n        results.push(result.value);\n        result = await reader.read();\n      }\n    })();\n\n    for (const chunk of testData) {\n      await channel.write(chunk);\n    }\n    await channel.close();\n\n    await readPromise;\n    expect(results).toEqual(testData);\n  });\n\n  it('should handle empty stream', async () => {\n    const channel = createStreamChannel<string>();\n    const reader = channel.stream().getReader();\n\n    await channel.close();\n\n    const result = await reader.read();\n    expect(result.done).toBe(true);\n  });\n\n  it('should handle non-awaited sequential writes', async () => {\n    const channel = createStreamChannel<number>();\n    const reader = channel.stream().getReader();\n\n    const testNumbers = Array.from({ length: 100 }, (_, i) => i);\n\n    for (const num of testNumbers) {\n      channel.write(num);\n    }\n    channel.close();\n\n    const results: number[] = [];\n    let result = await reader.read();\n    while (!result.done) {\n      results.push(result.value);\n      result = await reader.read();\n    }\n\n    expect(results).toEqual(testNumbers);\n  });\n\n  it('should handle double closing without error', async () => {\n    const channel = createStreamChannel<string>();\n    const reader = channel.stream().getReader();\n\n    await channel.write('test');\n\n    await channel.close();\n    // Close again - should not throw\n    await expect(channel.close()).resolves.toBeUndefined();\n\n    const result = await reader.read();\n    expect(result.done).toBe(false);\n    expect(result.value).toBe('test');\n\n    const nextResult = await reader.read();\n    expect(nextResult.done).toBe(true);\n  });\n\n  it('should gracefully handle close while read is pending', async () => {\n    const channel = createStreamChannel<string>();\n    const reader = channel.stream().getReader();\n\n    const readPromise = reader.read();\n\n    await channel.close();\n\n    const result = await readPromise;\n    expect(result.done).toBe(true);\n    expect(result.value).toBeUndefined();\n  });\n\n  it('should complete all pending reads when closed', async () => {\n    const channel = createStreamChannel<number>();\n    const reader = channel.stream().getReader();\n\n    const read1 = reader.read();\n    const read2 = reader.read();\n    const read3 = reader.read();\n\n    await channel.write(42);\n    await channel.write(43);\n    await channel.close();\n\n    const result1 = await read1;\n    expect(result1.done).toBe(false);\n    expect(result1.value).toBe(42);\n\n    const result2 = await read2;\n    expect(result2.done).toBe(false);\n    expect(result2.value).toBe(43);\n\n    const result3 = await read3;\n    expect(result3.done).toBe(true);\n  });\n});\n"],"mappings":"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","names":[]}